<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BUGGIFY - Testing Distributed Systems with Deterministic Simulation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><strong aria-hidden="true">1.</strong> Fault Injection</li><li><ol class="section"><li class="chapter-item expanded "><strong aria-hidden="true">1.1.</strong> System Faults</li><li class="chapter-item expanded "><a href="buggify.html" class="active"><strong aria-hidden="true">1.2.</strong> BUGGIFY</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Testing Distributed Systems with Deterministic Simulation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#buggify" id="buggify">BUGGIFY</a></h1>
<p>Simulation has built-in support for injecting low-level failures, and thus can productively discover failures of low-level components.  As lower-level abstractions are assembled into a higher-level system, simulation will lose effectiveness in finding high-level failures by injecting low-level bugs.  <code>BUGGIFY</code> bridges the gap to allow random injection of abstract, system component failures.</p>
<p><br/> <hr /> <br /></p>
<h3><a class="header" href="#behavior" id="behavior">Behavior</a></h3>
<p>FoundationDB's correctness is validated with a deterministic simulation framework that productively fuzzes faults against a specification of the system's behavior.</p>
<p>When I've seen discussions of FDB's testing in the wild, the focus has always been on the first part: the deterministic simulation framework.  This is likely due to Will Wilson's fantastic talk on the subject, <a href="https://youtu.be/4fFDFbi3toc">&quot;Testing Distributed Systems with Deterministic Simulation&quot;</a>, focusing mainly on that first part.  An important beginning, but not the whole story.</p>
<p>A deterministic simulation framework with random fault injection provides a testing framework that <em>can</em> find bugs.  However, the question is how quickly?  If validating the correctness of a network protocol or storage engine, then network or disk fault injection alone would be sufficient to give a high degree of confidence in correctness.  The types of dangerous conditions that the code must correctly handle, such as network instability or disk corruption, exactly match what the simulator directly produces.</p>
<p>When building full, higher level, distributed systems, there's no longer an exact match between what the simulator can easily produce and the dangerous situations that discover bugs.  What's the chance of random packet loss causing a minimal quorum to be used in two consecutive Raft leader elections?  What's the chance that random connection drops causes a duplicate request to be sent a minute later?  It's still <em>possible</em> for these bugs to be discovered, however, it'd take a tremendous number of simulation runs to stumble upon one of these higher-level dangerous situations.  This poor ratio of testing time to coverage, We've lost the &quot;productively&quot; in our original description of simulation testing.  What is needed is a way to enable the simulator to directly produce failures in higher level components or APIs.</p>
<p>How FoundationDB does this is with the <code>BUGGIFY</code> macro.  <code>BUGGIFY</code> exists to bias the simulator towards doing dangerous, bug-finding things.  It is the main tool that differentiates FDB's simulation testing from other black box solutions.  Instead of writing FoundationDB and then trying to validated it against a separate blackbox testing solution afterwards, FoundationDB was written to explicitly cooperate with the simulator by instrumenting its code with descriptions of how to cause failures in each component of the system.</p>
<p><code>BUGGIFY</code> has the following rules:</p>
<ol>
<li><code>BUGGIFY</code> only ever evaluates to true when run in simulation.</li>
<li>The first time each <code>BUGGIFY</code> use is evaluated, it is either enabled or disabled for the entire simulation run.</li>
<li>Enabled uses of <code>BUGGIFY</code> have a 5% chance of evaluating to true (or custom, e.g. <code>BUGGIFY_WITH_PROB(0.001)</code> == 0.1% chance).</li>
</ol>
<p>In FoundationDB all test code and <code>BUGGIFY</code> fault injection code is compiled into the exact binary that is published as the official binary and run in production.  (1) promising that <code>BUGGIFY</code> will only ever evaluate to true within simulation is what provides us with the sense of safety and confidence to liberally sprinkle fault injection code inline with our critical production code.</p>
<p>(2) and (3) are both different ways of requesting &quot;do bad things, but not too many of them&quot;. Viewing each <code>BUGGIFY</code> usage as a different potential type of fault, simulation selects a random subset of the potential faults to inject for a given run.  For the enabled <code>BUGGIFY</code> lines, we don't wish to force an error handling case in <em>every</em> run, as that might prevent the system from making forward progress.  5% was an arbitrarily chosen default for &quot;infrequent but not too infrequent&quot;.</p>
<p><br /> <hr /> <br /></p>
<h3><a class="header" href="#usage" id="usage">Usage</a></h3>
<h5><a class="header" href="#high-level-fault-injection" id="high-level-fault-injection">High-level Fault Injection</a></h5>
<ol>
<li>High level faults
<ol>
<li>Don't do work that's not strictly required for correctness</li>
<li></li>
<li>Pretend fail after success</li>
</ol>
</li>
</ol>
<p>As a last grouping, <code>if (BUGGIFY) wait(delay(5));</code> or <code>wait(delay( BUGGIFY ? 1, 0.001 ));</code> are reasonably common patterns in complex, concurrent code.  <code>delay()</code> itself is already equipped with a <code>BUGGIFY</code> to randomly lengthen the sleep duration, but due to <code>delay()</code>'s pervasive use across the codebase, it's set to a low chance of happening to avoid drastically lengthening test duration with sleeps.  Inserting additional delays at a higher level allows emphasizing those operations which might be vulnerable to delays.</p>
<p>As a concrete example, a FoundationDB transaction log will sometimes wait </p>
<pre><code class="language-cpp">if (isDisplaced) {
    // This TLog was removed from the database.
    if (BUGGIFY) wait( delay( SERVER_KNOBS-&gt;BUGGIFY_WORKER_REMOVED_MAX_LAG * deterministicRandom()-&gt;random01() ) );
    throw worker_removed();
}
</code></pre>
<p>Which allows simulation to more frequently test what happens if transaction logs stay as participants in the cluster longer than they're supposed to.</p>
<h5><a class="header" href="#randomizing-tuning-knobs" id="randomizing-tuning-knobs">Randomizing Tuning Knobs</a></h5>
<p>FoundationDB has a large collection of tuning knobs that can be used to fine tune FoundationDB's behavior to a particular deployment environment.  (748 of them at the time of writing.)  With these, one would wish some degree of testing that changing their default values is safe, and that changing a combination of them together is still safe.  The tuning knob initialization code uses <code>BUGGIFY</code> to randomize the tuning configuration.</p>
<p>This could be to choose a random setting for a single knob:</p>
<pre><code class="language-cpp">init( DESIRED_TEAMS_PER_SERVER, 5 );
if( randomize &amp;&amp; BUGGIFY )
    DESIRED_TEAMS_PER_SERVER = deterministicRandom()-&gt;random  Int(1, 10);
</code></pre>
<p>To verify that code hidden behind a feature flag is tested:</p>
<pre><code class="language-cpp">init( LOG_ROUTER_PEEK_FROM_SATELLITES_PREFERRED, 1 );
if( randomize &amp;&amp; BUGGIFY )
    LOG_ROUTER_PEEK_FROM_SATELLITES_PREFERRED = 0;
</code></pre>
<p>To make sure that default knob settings aren't masking bugs:</p>
<pre><code class="language-cpp">init( DD_MOVE_KEYS_PARALLELISM, 15 );
if( randomize &amp;&amp; BUGGIFY )
  DD_MOVE_KEYS_PARALLELISM = 1;
</code></pre>
<p>To force code that handles edge cases to run frequently:</p>
<pre><code class="language-cpp">init( MAX_COMMIT_UPDATES, 2000 );
if( randomize &amp;&amp; BUGGIFY )
    MAX_COMMIT_UPDATES = 1;
</code></pre>
<p>Or used to set a group of related knobs together:</p>
<pre><code class="language-cpp">bool smallTlogTarget = randomize &amp;&amp; BUGGIFY;
init( TARGET_BYTES_PER_TLOG,        2400e6 );
if( smallTlogTarget ) TARGET_BYTES_PER_TLOG = 2000e3;
init( SPRING_BYTES_TLOG,             400e6 );
if( smallTlogTarget ) SPRING_BYTES_TLOG = 200e3;
init( TARGET_BYTES_PER_TLOG_BATCH,  1400e6 );
if( smallTlogTarget ) TARGET_BYTES_PER_TLOG_BATCH = 1400e3;
init( SPRING_BYTES_TLOG_BATCH,       300e6 );
if( smallTlogTarget ) SPRING_BYTES_TLOG_BATCH = 150e3;
</code></pre>
<p>Some of these tuning knobs would have otherwise been hardcoded constants, but promoting them to a tuning knob was an easy way to allow their value to be subjected to <code>BUGGIFY</code>.</p>
<p>Knob configuration globally affects all code in the simulation test for the duration of the test.  Some instances might wish to <code>BUGGIFY</code> per instance or use:</p>
<pre><code class="language-cpp">// Knobs.cpp
init( FETCH_BLOCK_BYTES,               2e6 );
init( BUGGIFY_BLOCK_BYTES,            10000 );

// storageserver.actor.cpp
state int fetchBlockBytes = BUGGIFY ? SERVER_KNOBS-&gt;BUGGIFY_BLOCK_BYTES : SERVER_KNOBS-&gt;FETCH_BLOCK_BYTES;
</code></pre>
<p>Or set per object instantiated:</p>
<pre><code class="language-cpp">class RawDiskQueue_TwoFiles {
  public:
  RawDiskQueue_TwoFiles( /* parameters elided */ )
    : fileExtensionBytes(SERVER_KNOBS-&gt;DISK_QUEUE_FILE_EXTENSION_BYTES) {
      if (BUGGIFY) {
        fileExtensionBytes = _PAGE_SIZE * deterministicRandom()-&gt;randomSkewedUInt32( 1, 10&lt;&lt;10 );
      }
  }
};
</code></pre>
<p>Which in the end is to say: take all the constants and tuning knobs in your program, and <code>BUGGIFY</code> them either into a range of plausible production values, or a range of values that will increase testing coverage of the feature they control.  Use whichever trick illustrated above that gets you the most coverage.</p>
<h5><a class="header" href="#damage-control" id="damage-control">Damage Control</a></h5>
<p>As a last note on <code>BUGGIFY</code>, the goal of fault injection testing is to cause chaos, and then enforce that the system can correctly recover.  We random background fault injection, we need to define a point in time where the goal of the test becomes more about allowing the system to recover and end the test, than causing chaos.</p>
<p>This point is defined in FoundationDB as 300 seconds into a test, <code>g_simulator.speedUpSimulation</code> is set to true.  Various <code>BUGGIFY</code> lines that can cause extensive failures are instead written as</p>
<pre><code class="language-cpp">if (g_network-&gt;isSimulated() &amp;&amp;
    g_simulator.speedUpSimulation &amp;&amp;
    BUGGIFY_WITH_PROB(0.0001)) {
  throw master_recovery_failed();
}
</code></pre>
<p>So that they disable themselves once our goal is finishing the test, and not injecting as many failures as possible.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
